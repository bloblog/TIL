/*매출 데이터 분석*/
/*구매 지표 추출*/
-- [1-매출액-일별 매출액 조회를 위한 결합]

SELECT A.ORDERDATE, PRICEEACH*QUANTITYORDERED #매출액은 주문개수 곱하기 개당가격 (칼럼 따로 없어서 만들어줌)
FROM ORDERS A #주문날짜있는 테이블
    LEFT JOIN ORDERDETAILS B #개당가격과 주문개수 들어있는 테이블
    ON A.ORDERNUMBER = B.ORDERNUMBER; -- left 조인으로 연결해줌(디테일보다 주문내역이 더 중요해서 기준삼음)

-- [2-매출액-일별 매출액 조회] 일별!!
SELECT A.ORDERDATE, SUM(PRICEEACH*QUANTITYORDERED) AS SALES
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1 -- 결과의(select에서 지정) 첫번쨰 칼럼인 orderdate 의미
ORDER BY 1;

-- [3-문자열에서 원하는 부분만 가져오기 복습] 월별 매출액 조회 위한 추출
SELECT SUBSTR('ABCDE',2,3);

-- [4-매출액-월별 매출액 조회]
SELECT SUBSTR(A.ORDERDATE,1,7) MM, SUM(PRICEEACH*QUANTITYORDERED) AS SALES -- 연도 포함하기 위해 연-월 가져옴
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- [5-매출액-연도별 매출액 조회] 
SELECT SUBSTR(A.ORDERDATE,1,4) YY, SUM(PRICEEACH*QUANTITYORDERED) AS SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- [6] 한 구매자가 여러개 구매할 수도 있어서 체크
SELECT ORDERDATE,
CUSTOMERNUMBER,
ORDERNUMBER
FROM ORDERS
;

-- [7-주문번호 중복건 확인] 중복제거 하고 안하고 비교
SELECT COUNT(ORDERNUMBER) N_ORDERS,
	COUNT(DISTINCT ORDERNUMBER) N_ORDERS_DISTINCT
FROM ORDERS -- 이건 중복없는데
;

SELECT COUNT(CUSTOMERNUMBER) N_ORDERS,
	COUNT(DISTINCT CUSTOMERNUMBER) N_ORDERS_DISTINCT
FROM ORDERS -- 이건 중복 많다 326, 98로
;

-- [8-구매자수&구매건수-일?별] 
SELECT ORDERDATE,
	COUNT(DISTINCT CUSTOMERNUMBER) N_PURCHASER, 
	COUNT(ORDERNUMBER) N_ORDERS -- 중복 없어서 그냥 카운트
FROM ORDERS
GROUP BY 1
ORDER BY 1;

-- [9-인당매출액-연도별 매출액&구매자수] 
SELECT SUBSTR(A.ORDERDATE,1,4) YY,
	COUNT(DISTINCT A.CUSTOMERNUMBER) N_PURCHASER,
	SUM(PRICEEACH*QUANTITYORDERED) AS SALES
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- [9-1-인당매출액-월별 매출액&구매자수] 
SELECT SUBSTR(A.ORDERDATE,1,7) MM,
	COUNT(DISTINCT A.CUSTOMERNUMBER) N_PURCHASER,
	SUM(PRICEEACH*QUANTITYORDERED) AS SALES
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- [10-인당매출액-9번결과(연도별)에 매출액을 구매자수(중복제거)로 나누기] 충성도 파악에 사용
SELECT SUBSTR(A.ORDERDATE,1,4) YY,
	COUNT(DISTINCT A.CUSTOMERNUMBER) N_PURCHASER,
	SUM(PRICEEACH*QUANTITYORDERED) AS SALES,
	SUM(PRICEEACH*QUANTITYORDERED) / COUNT(DISTINCT A.CUSTOMERNUMBER) AMV
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- [11-ATV-건당구매금액] -- 한 건에 얼마 냈는지. 구매자 수 대신 구매건수로 나눈다.
SELECT SUBSTR(A.ORDERDATE,1,4) YY,
	COUNT(DISTINCT A.ORDERNUMBER) N_ORDERS,
	SUM(PRICEEACH*QUANTITYORDERED) AS SALES,
	SUM(PRICEEACH*QUANTITYORDERED)/ COUNT(DISTINCT A.ORDERNUMBER) ATV
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
	ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY 1
ORDER BY 1;		

-- 누계구하기
-- [12-날짜별 매출을 일시 테이블로]
WITH
DAILY_PURCHASE AS ( 
SELECT A.ORDERDATE,
	SUBSTR(A.ORDERDATE,1,4) AS YY,
	SUBSTR(A.ORDERDATE,6,2) AS MM,
	SUBSTR(A.ORDERDATE,9,2) AS DD,
	SUM(PRICEEACH*QUANTITYORDERED) AS PURCHASE_AMOUNT,
	COUNT(A.ORDERNUMBER) AS ORDER_CNT
FROM ORDERS A
	LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY ORDERDATE
)
SELECT *
FROM DAILY_PURCHASE
ORDER BY ORDERDATE;

-- [13-당월 누계 매출 집계]
WITH
DAILY_PURCHASE AS (
SELECT A.ORDERDATE,
	SUBSTR(A.ORDERDATE,1,4) AS YY,
	SUBSTR(A.ORDERDATE,6,2) AS MM,
	SUBSTR(A.ORDERDATE,9,2) AS DD,
	SUM(B.QUANTITYORDERED) AS PURCHASE_AMOUNT,
	COUNT(A.ORDERNUMBER) AS ORDER_CNT
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY ORDERDATE
)
SELECT ORDERDATE,
	CONCAT(YY, '-', MM) AS YY_MM,
	PURCHASE_AMOUNT,
	SUM(PURCHASE_AMOUNT) OVER(PARTITION BY YY, MM ORDER BY ORDERDATE ROWS UNBOUNDED PRECEDING) AS AGG_AMOUNT
FROM DAILY_PURCHASE
ORDER BY ORDERDATE
;

-- [14-월별 매출과 작년 대비 비율 집계] 작대비
WITH
DAILY_PURCHASE AS (
SELECT A.ORDERDATE,
	SUBSTR(A.ORDERDATE,1,4) AS YY,
	SUBSTR(A.ORDERDATE,6,2) AS MM,
	SUBSTR(A.ORDERDATE,9,2) AS DD,
	SUM(PRICEEACH*QUANTITYORDERED) AS PURCHASE_AMOUNT,
	COUNT(A.ORDERNUMBER) AS ORDER_CNT
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY ORDERDATE
)
SELECT MM,
	SUM(CASE YY WHEN '2003' THEN PURCHASE_AMOUNT END) AS AMOUNT_2003,
	SUM(CASE YY WHEN '2004' THEN PURCHASE_AMOUNT END) AS AMOUNT_2004,
	100.0 * SUM(CASE YY WHEN '2004' THEN PURCHASE_AMOUNT END) / SUM(CASE YY WHEN '2003' THEN PURCHASE_AMOUNT END) AS RATE_2003_2004 
FROM DAILY_PURCHASE
GROUP BY MM
ORDER BY MM;

-- [15-Z차트-2004년 매출]
WITH
DAILY_PURCHASE AS (
SELECT A.ORDERDATE,
	SUBSTR(A.ORDERDATE,1,4) AS YY,
	SUBSTR(A.ORDERDATE,6,2) AS MM,
	SUBSTR(A.ORDERDATE,9,2) AS DD,
	SUM(PRICEEACH*QUANTITYORDERED) AS PURCHASE_AMOUNT,
	COUNT(A.ORDERNUMBER) AS ORDER_CNT
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
GROUP BY ORDERDATE
),
MONTHLY_AMOUNT AS (
SELECT YY, MM,
	SUM(PURCHASE_AMOUNT) AS AMOUNT
FROM DAILY_PURCHASE
GROUP BY YY, MM
),
CALC_INDEX AS (
SELECT YY, MM, AMOUNT,
	SUM(CASE WHEN YY='2004' THEN AMOUNT END) OVER(ORDER BY YY, MM ROWS UNBOUNDED PRECEDING) AS AGG_AMOUNT,
	SUM(AMOUNT) OVER(ORDER BY YY, MM ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS YY_AVG_AMOUNT
	-- 지금으로부터 11개 앞부터 현재 행까지(between~ and~) 이동누계
FROM MONTHLY_AMOUNT -- 앞의 월별합계 일시테이블 사용
ORDER BY YY, MM
)
SELECT CONCAT(YY, '-', MM) AS YY_MM,
	AMOUNT,
	AGG_AMOUNT,
	YY_AVG_AMOUNT
FROM CALC_INDEX
WHERE YY='2004'
ORDER BY YY_MM
;


/*그룹별 구매 지표*/
-- [16-국가별/도시별매출액-테이블조합]
SELECT *
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
;
-- 여기서 국가 도시 매출액만 뽑으면 되겠다!

-- [17-국가별/도시별매출액-12번결과에서 필요한 부분만]
SELECT COUNTRY,CITY,PRICEEACH*QUANTITYORDERED
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
;

-- [18-국가별/도시별매출액-13번결과에서 그룹핑 및 매출액]
SELECT C.COUNTRY,
C.CITY,
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1,2 -- 나라와 도시 엮기?
;

-- [19-국가별/도시별매출액-14번결과에서 가독성 있게 ORDERBY로 정렬]
SELECT C.COUNTRY,
C.CITY,
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1,2
ORDER BY 1,2
;

-- [20-북미비북미매출액비교-CASE구문복습]
SELECT CASE WHEN COUNTRY IN ('USA','Canada') THEN 'North America'
ELSE 'Others' END COUNTRY_GRP
-- 미국이나 캐나다 아니면 others로 기록(표현)해라
FROM CUSTOMERS; 

-- [21-북미비북미매출액비교-15번결과에서정렬기준만변경]
SELECT C.COUNTRY,
C.CITY,
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1,2
ORDER BY 3 DESC -- 3 = 매출액
;

-- [22-북미비북미매출액비교]
SELECT CASE WHEN COUNTRY IN ('USA','Canada') THEN 'North America'
ELSE 'Others' END COUNTRY_GRP,
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1
ORDER BY 2 DESC
;

-- [23-매출탑5국가/매출-국가별매출액결과 테이블생성]
CREATE TABLE STAT AS -- stat이라는 이름의 테이블 만듦(with문 계속하기 귀찮)
SELECT C.COUNTRY,
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1
ORDER BY 2 DESC
;

-- [24-매출탑5국가/매출-테이블확인]
SELECT *
FROM STAT;

-- [25-매출탑5국가/매출-매출액등수매기기]
SELECT COUNTRY,
SALES,
DENSE_RANK() OVER(ORDER BY SALES DESC) RNK -- 공동이 있어도 포함하도록. 윈도우함수
FROM STAT;

-- [26-매출탑5국가/매출-테이블생성]
CREATE TABLE STAT_RNK AS
SELECT COUNTRY,
SALES,
DENSE_RANK() OVER(ORDER BY SALES DESC) RNK
FROM STAT;

-- [27-매출탑5국가/매출-테이블확인]
SELECT *
FROM STAT_RNK;

-- [28-매출탑5국가/매출-상위5개국가]
SELECT *
FROM  STAT_RNK
WHERE RNK BETWEEN 1 AND 5; -- 1위에서 5위 출력

-- [29-매출탑5국가/매출-SUBQUERY로 한번에]
SELECT *
FROM -- with문 대신
(SELECT COUNTRY, -- 랭킹 매기는 구문 앞에서의 STAT_RNK
SALES,
DENSE_RANK() OVER(ORDER BY SALES DESC) RNK
FROM
(SELECT C.COUNTRY, -- 국가별 매출액 구하는 구문 앞에서의 STAT
SUM(PRICEEACH*QUANTITYORDERED) SALES
FROM ORDERS A
    LEFT JOIN ORDERDETAILS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1) A) A
WHERE RNK <= 5
;

-- [30-ABC분석-매출구성비누계&등급계산]
WITH 
M    ONTHLY_SALES AS ( -- 일시테이블1
SELECT C.PRODUCTLINE, -- 일종의 제품카테고리
SUM(PRICEEACH*QUANTITYORDERED) AS AMOUNT
FROM ORDERDETAILS A
    LEFT JOIN ORDERS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN PRODUCTS C
    ON A.PRODUCTCODE = C.PRODUCTCODE
WHERE SUBSTR(B.ORDERDATE,1,7) = '2004-01'
GROUP BY PRODUCTLINE -- 카테고리별로 구분
),
SALES_COMPOSITI    ON_RATIO AS ( -- 일시테이블2. 비율구하기
SELECT PRODUCTLINE,
AMOUNT,
100.0 * AMOUNT / SUM(AMOUNT) OVER() AS COMPOSITI    ON_RATIO, -- 구성비. amount는 항목별 매출
100.0 * SUM(AMOUNT) OVER(ORDER BY AMOUNT DESC
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) 
-- between ~row 이거 왜하냐 방향지정 
/ SUM(AMOUNT) OVER() AS CUMULATIVE_RATIO -- 구성비누계. 그룹바이 된 걸 합쳐주겠다 그래서 over()사용
-- rows~ 어디부터 어디까지 누적시킬지 선택. 항목별 누적매출을 전체 매출로 나눈다.
FROM M    ONTHLY_SALES
)
SELECT *,
CASE WHEN CUMULATIVE_RATIO BETWEEN 0 AND 70 THEN 'A'
	WHEN CUMULATIVE_RATIO BETWEEN 70 AND 90 THEN 'B'
	WHEN CUMULATIVE_RATIO BETWEEN 90 AND 100 THEN 'C'
    END AS ABC_RANK
FROM SALES_COMPOSITI    ON_RATIO
ORDER BY AMOUNT DESC
;


-- [32-재구매율-원리이해]
SELECT A.CUSTOMERNUMBER,
A.ORDERDATE,
B.CUSTOMERNUMBER,
B.ORDERDATE
FROM ORDERS A
    LEFT JOIN ORDERS B
    ON A.CUSTOMERNUMBER = B.CUSTOMERNUMBER AND SUBSTR(A.ORDERDATE,1,4)
= SUBSTR(B.ORDERDATE,1,4) -1; -- And이하 : 해당 연도와 작년 자료 매칭시키도록 연결조건 걺
-- 363번 고객이 2003-01-06에 구매했고 2004-11-04에도 구매했다/ 작년에 한번, 올해에 엄청 많이 구매할수도

-- [33-재구매율-국가별]
SELECT C.COUNTRY,
SUBSTR(A.ORDERDATE,1,4) YY,
COUNT(DISTINCT A.CUSTOMERNUMBER) BU_1, -- ex 2003년도 재구매인원
COUNT(DISTINCT B.CUSTOMERNUMBER) BU_2, -- 	->2004년도 재구매인원
COUNT(DISTINCT B.CUSTOMERNUMBER)/COUNT(DISTINCT A.CUSTOMERNUMBER)
RETENTI    ON_RATE
FROM ORDERS A
    LEFT JOIN ORDERS B
    ON A.CUSTOMERNUMBER = B.CUSTOMERNUMBER AND SUBSTR(A.ORDERDATE,1,4)
= SUBSTR(B.ORDERDATE,1,4)-1
    LEFT JOIN CUSTOMERS C
    ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER -- 한번더 조인
GROUP BY 1,2
;

-- [34-베스트셀러-미국 연도별 탑5]
CREATE TABLE PRODUCT_SALES AS
SELECT D.PRODUCTNAME,
SUM(QUANTITYORDERED*PRICEEACH) SALES
FROM ORDERS A
    LEFT JOIN CUSTOMERS B
    ON A.CUSTOMERNUMBER = B.CUSTOMERNUMBER
    LEFT JOIN ORDERDETAILS C
    ON A.ORDERNUMBER = C.ORDERNUMBER
    LEFT JOIN PRODUCTS D
    ON C.PRODUCTCODE = D.PRODUCTCODE
WHERE B.COUNTRY = 'USA'
GROUP BY 1
;

SELECT *
FROM
(SELECT *,
ROW_NUMBER() OVER(ORDER BY SALES DESC) RNK
FROM PRODUCT_SALES) A
WHERE RNK <=5
ORDER BY RNK
;

-- [35-이탈률-마지막구매일 확인]
SELECT MAX(ORDERDATE) MX_ORDER -- 가장 최근 날짜
FROM ORDERS;

-- [36-이탈률-고객별 마지막구매일]
SELECT CustomerNumber, MAX(ORDERDATE) MX_ORDER
FROM ORDERS
GROUP BY 1; -- 고객별

-- [37-이탈률-마지막구매일 기준 소요일 계산]
SELECT CUSTOMERNUMBER,
MX_ORDER,
'2005-06-01',
DATEDIFF('2005-06-01',MX_ORDER) DIFF -- 마지막 구매로부터 얼마나 지났는지
FROM
(SELECT CUSTOMERNUMBER, -- 마지막 구매일 구하는 서브쿼리
MAX(ORDERDATE) MX_ORDER
FROM ORDERS
GROUP BY 1) BASE
;

-- [38-이탈률-90일이상] -- DIFF 가 90이상이면 이탈고객으로 간주
SELECT *,
CASE WHEN DIFF >= 90 THEN 'CHURN' ELSE 'N    ON-CHURN' END CHURN_TYPE
FROM
(SELECT CUSTOMERNUMBER,
MX_ORDER,
'2005-06-01' END_POINT,
DATEDIFF('2005-06-01',MX_ORDER) DIFF
FROM
(SELECT CUSTOMERNUMBER,
MAX(ORDERDATE) MX_ORDER
FROM ORDERS
GROUP BY 1) BASE) BASE
;

-- [39-이탈률-이탈률 계산] 
SELECT CASE WHEN DIFF >= 90 THEN 'CHURN' ELSE 'N    ON-CHURN' END CHURN_TYPE,
COUNT(DISTINCT CUSTOMERNUMBER) N_CUS -- 이탈고객 수 출력
FROM
(SELECT CUSTOMERNUMBER,
MX_ORDER,
'2005-06-01' END_POINT,
DATEDIFF('2005-06-01',MX_ORDER) DIFF
FROM
(SELECT CUSTOMERNUMBER,
MAX(ORDERDATE) MX_ORDER
FROM ORDERS
GROUP BY 1) BASE) BASE
GROUP BY 1
;

-- [40-이탈고객특성-고객별 Churn table 생성]
CREATE TABLE CHURN_LIST AS
SELECT CASE WHEN DIFF >= 90 THEN 'CHURN' ELSE 'N    ON-CHURN' END CHURN_TYPE,
CUSTOMERNUMBER
FROM
(SELECT CUSTOMERNUMBER,
MX_ORDER,
'2005-06-01' END_POINT,
DATEDIFF('2005-06-01',MX_ORDER) DIFF
FROM
(SELECT CUSTOMERNUMBER,
MAX(ORDERDATE) MX_ORDER
FROM ORDERS
GROUP BY 1) BASE) BASE -- BASE이게뭐지?
;

-- [41-이탈고객특성-생산라인별 구매자수] 
SELECT C.PRODUCTLINE,
COUNT(DISTINCT B.CUSTOMERNUMBER) BU
FROM ORDERDETAILS A
    LEFT JOIN ORDERS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN PRODUCTS C
    ON A.PRODUCTCODE = C.PRODUCTCODE
GROUP BY 1
;

-- [42-이탈고객특성-이탈과 생산라인 비교] --churn표도 조인
SELECT D.CHURN_TYPE,
C.PRODUCTLINE,
COUNT(DISTINCT B.CUSTOMERNUMBER) BU
FROM ORDERDETAILS A
    LEFT JOIN ORDERS B
    ON A.ORDERNUMBER = B.ORDERNUMBER
    LEFT JOIN PRODUCTS C
    ON A.PRODUCTCODE = C.PRODUCTCODE
    LEFT JOIN CHURN_LIST D
    ON B.CUSTOMERNUMBER = D.CUSTOMERNUMBER -- 이탈 고객이 어떤 생산라인의 제품을 구매했었는지
GROUP BY 1,2
ORDER BY 1,3 DESC;
